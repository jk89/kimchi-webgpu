// Represents a 256-bit integer as 8 32-bit limbs (little-endian)
// limbs[0] = least significant 32 bits
struct Limbs256 {
    limbs: array<u32, 8>       // limbs[0] = least significant 32 bits
}

// Represents a point in affine coordinates over a 256-bit field
// x, y coordinates are in Montgomery form
struct Point256 {
    x: Limbs256                // x-coordinate of the point
    y: Limbs256                // y-coordinate of the point
}

// Represents a point in projective coordinates over a 256-bit field
// x, y, z are in Montgomery form
// Point at infinity if Z = 0
struct ProjectivePoint256 {
    x: Limbs256                // Projective x coordinate
    y: Limbs256                // Projective y coordinate
    z: Limbs256                // Projective z coordinate (point at infinity if z = 0)
}

// Represents the parameters of a 256-bit elliptic curve
// p      : prime modulus of the field
// r2     : R² mod p, for Montgomery conversion
// mont_inv32 : -p⁻¹ mod 2^32 for Montgomery reduction
// a, b   : curve coefficients
// p_minus_2  : p - 2, used for modular inverse via Fermat's little theorem
struct Curve256 {
    p: array<u32, 8>,          // Prime modulus of the curve (field size)
    r2: array<u32, 8>,         // R² mod p, used for converting numbers into Montgomery form
    mont_inv32: u32,           // -p⁻¹ mod 2^32, used in Montgomery reduction
    a: array<u32, 8>,          // Curve coefficient 'a' in the equation y² = x³ + a*x + b
    b: array<u32, 8>,          // Curve coefficient 'b' in the equation y² = x³ + a*x + b
    p_minus_2: array<u32, 8>,  // p - 2, for computing modular inverse: a^(-1) = a^(p-2) mod p
};

// Pallas curve MSM with Montgomery multiplication
// Curve equation: y² = x³ + 5

// Pallas prime modulus (field size)  
const PALLAS_P: array<u32, 8> = array<u32, 8>(
    0x00000001u, 0x992d30edu, 0x094cf91bu, 0x224698fcu,
    0x00000000u, 0x00000000u, 0x00000000u, 0x40000000u
);

// Pallas R² mod p, used to convert numbers into Montgomery form for fast arithmetic  
const PALLAS_R2: array<u32, 8> = array<u32, 8>(
    0x8c46eb20, 0x748d9d99, 0x7523e5ce, 0x1a5f79f5,
    0xffd8ddee, 0x0, 0x0, 0x0
);

// Pallas -p⁻¹ mod 2^32, required for Montgomery reduction in field operations  
const PALLAS_MONT_INV32: u32 = 0xffffffffu;

// Pallas curve coefficient 'a' in y² = x³ + a*x + b (here a = 0 for Pallas)  
const PALLAS_A: array<u32, 8> = array<u32, 8>(
    0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u
);

// Pallas curve coefficient 'b' in y² = x³ + a*x + b (here b = 5 for Pallas)  
const PALLAS_B: array<u32, 8> = array<u32, 8>(
    0u, 0u, 0u, 0u, 0u, 0u, 0u, 5u
);

// Pallas p - 2, used for modular inverse computation
const PALLAS_P_MINUS_2: array<u32, 8> = array<u32, 8>(
    0xFFFFFFFFu, 0x992d30ecu, 0x094cf91bu, 0x224698fcu,
    0x00000000u, 0x00000000u, 0x00000000u, 0x40000000u
);

// Complete Pallas curve parameters as a Curve256 instance  
const PALLAS_CURVE: Curve256 = Curve256(PALLAS_P, PALLAS_R2, PALLAS_MONT_INV32, PALLAS_A, PALLAS_B, PALLAS_P_MINUS_2);

// Compare two 256-bit integers
// Inputs: a, b : 256-bit integers
// Output: true if a >= b
// Path: compare most significant limb first, stop at first difference
fn gte_256(a: array<u32, 8>, b: array<u32, 8>) -> bool {
    var i: i32 = 7;
    loop {
        if (i < 0) { break; }
        if (a[i] > b[i]) { return true; }
        if (a[i] < b[i]) { return false; }
        i = i - 1;
    }
    return true;
}

// Subtract two 256-bit integers without underflow
// Inputs: a, b : 256-bit integers
// Output: result = a - b (wraparound prevented)
// Formula: result[i] = a[i] - b[i] - borrow_from_previous
// borrow = 1 if previous subtraction underflowed, 0 otherwise
fn sub_no_borrow_256(a: array<u32, 8>, b: array<u32, 8>) -> array<u32, 8> {
    var result: array<u32, 8>;
    var borrow: u32 = 0u;
    
    for (var i = 0u; i < 8u; i = i + 1u) {
        let ai = a[i];
        let bi = b[i];
        
        if (ai >= (bi + borrow)) {
            result[i] = ai - bi - borrow;
            borrow = 0u;
        } else {
            let temp = 0xFFFFFFFFu - bi - borrow + 1u;
            result[i] = temp + ai;
            borrow = 1u;
        }
    }
    
    return result;
}

// Modular addition: (a + b) mod p
// Inputs: a, b : 256-bit integers; p : modulus
// Output: (a + b) mod p
// Path: limb-wise addition with carry; subtract p if result >= p
fn add_mod_256(a: array<u32, 8>, b: array<u32, 8>, p: array<u32, 8>) -> array<u32, 8> {
    var result: array<u32, 8>;
    var carry: u32 = 0u;
    
    for (var i = 0u; i < 8u; i = i + 1u) {
        let sum_low = a[i] + b[i];
        let carry_from_low = u32(sum_low < a[i]);
        
        let sum_with_carry = sum_low + carry;
        let carry_from_carry = u32(sum_with_carry < sum_low);
        
        result[i] = sum_with_carry;
        carry = carry_from_low + carry_from_carry;
    }
    
    if (carry != 0u || gte_256(result, p)) {
        result = sub_no_borrow_256(result, p);
    }
    
    return result;
}

// Modular subtraction: (a - b) mod p
// Inputs: a, b : 256-bit integers; p : modulus
// Output: (a - b) mod p
// Path: if a >= b, result = a - b; else result = p - (b - a)
fn sub_mod_256(a: array<u32, 8>, b: array<u32, 8>, p: array<u32, 8>) -> array<u32, 8> {
    if (gte_256(a, b)) {
        return sub_no_borrow_256(a, b);
    } else {
        let diff = sub_no_borrow_256(b, a);
        return sub_no_borrow_256(p, diff);
    }
}

// Multiply two 32-bit integers and accumulate with carry
// Inputs: a, b : u32 integers; acc : current limb value; carry : propagated carry
// Output: updated limb = (a*b + acc + *carry) mod 2^32
// Path: split a, b into high/low 16-bit halves, compute cross-products, propagate carry
fn mul_add_carry(a: u32, b: u32, acc: u32, carry: ptr<function, u32>) -> u32 {
    let a_lo = a & 0xFFFFu;
    let a_hi = a >> 16u;
    let b_lo = b & 0xFFFFu;
    let b_hi = b >> 16u;
    
    let p0 = a_lo * b_lo;
    let p1 = a_lo * b_hi;
    let p2 = a_hi * b_lo;
    let p3 = a_hi * b_hi;
    
    let mid = p1 + p2;
    let mid_carry = u32(mid < p1);
    
    let low = p0 + (mid << 16u);
    let low_carry = u32(low < p0);
    
    let high = p3 + (mid >> 16u) + mid_carry + low_carry;
    
    let result = low + acc;
    let result_carry = u32(result < low);
    
    let final_result = result + *carry;
    let final_carry = u32(final_result < result);
    
    *carry = high + result_carry + final_carry;
    return final_result;
}

// Montgomery reduction: REDC(T) = T * R^-1 mod p
// Inputs:
//   t          : 512-bit integer (16 u32 limbs)
//   mont_inv32 : -p⁻¹ mod 2^32
//   p          : prime modulus
// Output: 256-bit integer = T * R^-1 mod p
// Path:
//   For each limb i of t:
//     m = t[i] * mont_inv32
//     temp += m * p -> t[i] becomes 0
//   Upper 256 bits = result
//   If result >= p, subtract p
fn montgomery_reduce_256(t: array<u32, 16>, mont_inv32: u32, p: array<u32, 8>) -> array<u32, 8> {
    var temp = t;
    
    // Montgomery reduction loop
    for (var i = 0u; i < 8u; i = i + 1u) {
        // m = temp[i] * mont_inv32 mod 2^32
        let m = temp[i] * mont_inv32;
        
        // temp += m * p (this makes temp[i] = 0)
        var carry: u32 = 0u;
        for (var j = 0u; j < 8u; j = j + 1u) {
            temp[i + j] = mul_add_carry(m, p[j], temp[i + j], &carry);
        }
        
        // Propagate carry to high limbs
        var k = i + 8u;
        loop {
            if (k >= 16u || carry == 0u) { break; }
            let sum = temp[k] + carry;
            carry = u32(sum < temp[k]);
            temp[k] = sum;
            k = k + 1u;
        }
    }
    
    // Extract upper 256 bits (temp >> 256)
    var result: array<u32, 8>;
    for (var i = 0u; i < 8u; i = i + 1u) {
        result[i] = temp[i + 8u];
    }
    
    // Final conditional subtraction
    if (gte_256(result, p)) {
        result = sub_no_borrow_256(result, p);
    }
    
    return result;
}

// Montgomery multiplication: (a * b * R^-1) mod p
// Inputs: a, b : 256-bit integers; mont_inv32, p : parameters
// Output: 256-bit integer = a * b * R^-1 mod p
// Path: compute 512-bit product, then Montgomery reduce
fn mont_mul_256(a: array<u32, 8>, b: array<u32, 8>, mont_inv32: u32, p: array<u32, 8>) -> array<u32, 8> {
    var product: array<u32, 16>;
    
    // Compute a * b
    for (var i = 0u; i < 8u; i = i + 1u) {
        var carry: u32 = 0u;
        for (var j = 0u; j < 8u; j = j + 1u) {
            product[i + j] = mul_add_carry(a[i], b[j], product[i + j], &carry);
        }
        product[i + 8u] = carry;
    }
    
    return montgomery_reduce_256(product, mont_inv32, p);
}

// Convert a 256-bit integer to Montgomery form
// Inputs: a, r2, mont_inv32, p
// Output: a * R mod p
fn to_montgomery_256(a: array<u32, 8>, r2: array<u32, 8>, mont_inv32: u32, p: array<u32, 8>) -> array<u32, 8> {
    return mont_mul_256(a, r2, mont_inv32, p);
}

// Convert a 256-bit integer from Montgomery form
// Inputs: a, mont_inv32, p
// Output: a * R^-1 mod p
fn from_montgomery(a: array<u32, 8>, mont_inv32: u32, p: array<u32, 8>) -> array<u32, 8> {
    var temp: array<u32, 16>;
    for (var i = 0u; i < 8u; i = i + 1u) {
        temp[i] = a[i];
    }
    // Check this
    for (var i = 8u; i < 16u; i = i + 1u) {
        temp[i] = 0u;
    }
    return montgomery_reduce_256(temp, mont_inv32, p);
}

// Modular inverse in Montgomery form
// Inputs: a : 256-bit integer in Montgomery form
//         r2, mont_inv32, p : parameters
//         p_minus_2 : p-2 for Fermat's inverse
// Output: a^-1 mod p in Montgomery form
// Path: exponentiation by squaring: result = a^(p-2)
fn mod_inverse_mont_256(a: array<u32, 8>, r2: array<u32, 8>, mont_inv32: u32, p: array<u32, 8>, p_minus_2: array<u32, 8>) -> array<u32, 8> {
    var result: array<u32, 8>;
    result[0] = 1u;
    for (var i = 1u; i < 8u; i = i + 1u) {
        result[i] = 0u;
    }
    result = to_montgomery_256(result, r2, mont_inv32, p); // 1 in Montgomery form
    
    var base = a; // Already in Montgomery form
    
    for (var limb_idx = 0u; limb_idx < 8u; limb_idx = limb_idx + 1u) {
        var bits = p_minus_2[limb_idx];
        
        for (var bit = 0u; bit < 32u; bit = bit + 1u) {
            if ((bits & 1u) == 1u) {
                result = mont_mul_256(result, base, mont_inv32, p);
            }
            base = mont_mul_256(base, base, mont_inv32, p);
            bits = bits >> 1u;
        }
    }
    
    return result;
}

// Check if projective point P is infinity (z == 0)
fn is_infinity_proj_256(P: ProjectivePoint256) -> bool {
    for (var i = 0u; i < 8u; i = i + 1u) {
        if (P.z.limbs[i] != 0u) {
            return false;
        }
    }
    return true;
}

// Convert affine point (x, y) to projective coordinates (x:y:z)
// Inputs: x, y : Limbs256, r2, mont_inv32, p
// Output: ProjectivePoint256 P in Montgomery form, z = 1
fn to_projective_256(x: Limbs256, y: Limbs256, r2: array<u32, 8>, mont_inv32: u32, p: array<u32, 8>) -> ProjectivePoint256 {
    var P: ProjectivePoint256;
    // Convert to Montgomery form
    P.x.limbs = to_montgomery_256(x.limbs, r2, mont_inv32, p);
    P.y.limbs = to_montgomery_256(y.limbs, r2, mont_inv32, p);
    P.z.limbs[0] = 1u;
    for (var i = 1u; i < 8u; i = i + 1u) {
        P.z.limbs[i] = 0u;
    }
    P.z.limbs = to_montgomery_256(P.z.limbs, r2, mont_inv32, p);
    return P;
}

// Convert projective point to affine coordinates
// Inputs: P : ProjectivePoint256, r2, mont_inv32, p, p_minus_2
// Output: Q : Point256 (x, y) in affine coordinates
// Path:
//   If z == 0, return (0,0)
//   Compute z_inv = z^-1 mod p
//   x_affine = x * z_inv, y_affine = y * z_inv
//   Convert x_affine, y_affine from Montgomery form
fn to_affine_256(P: ProjectivePoint256, r2: array<u32, 8>, mont_inv32: u32, p: array<u32, 8>, p_minus_2: array<u32, 8>) -> Point256 {
    if (is_infinity_proj_256(P)) {
        var inf: Point256;
        for (var i = 0u; i < 8u; i = i + 1u) {
            inf.x.limbs[i] = 0u;
            inf.y.limbs[i] = 0u;
        }
        return inf;
    }
    
    let z_inv = mod_inverse_mont_256(P.z.limbs, r2, mont_inv32, p, p_minus_2);
    
    var Q: Point256;
    Q.x.limbs = mont_mul_256(P.x.limbs, z_inv, mont_inv32, p);
    Q.y.limbs = mont_mul_256(P.y.limbs, z_inv, mont_inv32, p);
    
    // Convert back from Montgomery form
    Q.x.limbs = from_montgomery(Q.x.limbs, mont_inv32, p);
    Q.y.limbs = from_montgomery(Q.y.limbs, mont_inv32, p);
    
    return Q;
}

// Point doubling in projective coordinates
// Inputs: P : ProjectivePoint256, r2, mont_inv32, p
// Output: Q = 2*P in projective coordinates
// Path:
//   xx = x^2, yy = y^2, yyyy = yy^2, zz = z^2
//   s  = 2*((x+yy)^2 - xx - yyyy)
//   m  = 3*xx
//   x3 = m^2 - 2*s
//   y3 = m*(s - x3) - 8*yyyy
//   z3 = (y+z)^2 - yy - zz
fn point_double_proj_256(P: ProjectivePoint256, r2: array<u32, 8>, mont_inv32: u32, p: array<u32, 8>) -> ProjectivePoint256 {
    if (is_infinity_proj_256(P)) { return P; }
    
    let xx = mont_mul_256(P.x.limbs, P.x.limbs, mont_inv32, p);
    let yy = mont_mul_256(P.y.limbs, P.y.limbs, mont_inv32, p);
    let yyyy = mont_mul_256(yy, yy, mont_inv32, p);
    let zz = mont_mul_256(P.z.limbs, P.z.limbs, mont_inv32, p);
    
    var s = add_mod_256(P.x.limbs, yy, p);
    s = mont_mul_256(s, s, mont_inv32, p);
    s = sub_mod_256(s, xx, p);
    s = sub_mod_256(s, yyyy, p);
    s = add_mod_256(s, s, p);
    
    var m = add_mod_256(xx, xx, p);
    m = add_mod_256(m, xx, p);
    
    var t = mont_mul_256(m, m, mont_inv32, p);
    t = sub_mod_256(t, add_mod_256(s, s, p), p);
    
    var Q: ProjectivePoint256;
    Q.x.limbs = t;
    
    var y3 = sub_mod_256(s, t, p);
    y3 = mont_mul_256(m, y3, mont_inv32, p);
    var yyyy8 = add_mod_256(yyyy, yyyy, p);
    yyyy8 = add_mod_256(yyyy8, yyyy8, p);
    yyyy8 = add_mod_256(yyyy8, yyyy8, p);
    Q.y.limbs = sub_mod_256(y3, yyyy8, p);
    
    var z3 = add_mod_256(P.y.limbs, P.z.limbs, p);
    z3 = mont_mul_256(z3, z3, mont_inv32, p);
    z3 = sub_mod_256(z3, yy, p);
    z3 = sub_mod_256(z3, zz, p);
    Q.z.limbs = z3;
    
    return Q;
}

// Point addition in projective coordinates
// Inputs: P, Q : ProjectivePoint256, r2, mont_inv32, p
// Output: R = P + Q in projective coordinates
// Path:
//   z1z1 = z1^2, z2z2 = z2^2
//   u1 = x1*z2z2, u2 = x2*z1z1
//   s1 = y1*z2*z2z2, s2 = y2*z1*z1z1
//   If u1 == u2 and s1 == s2, return 2*P
//   h = u2 - u1, i = (2*h)^2, j = h*i
//   r = 2*(s2 - s1), v = u1*i
//   x3 = r^2 - j - 2*v
//   y3 = r*(v - x3) - 2*s1*j
//   z3 = ((z1+z2)^2 - z1z1 - z2z2)*h
fn point_add_proj_256(P: ProjectivePoint256, Q: ProjectivePoint256, r2: array<u32, 8>, mont_inv32: u32, p: array<u32, 8>) -> ProjectivePoint256 {
    if (is_infinity_proj_256(P)) { return Q; }
    if (is_infinity_proj_256(Q)) { return P; }
    
    let z1z1 = mont_mul_256(P.z.limbs, P.z.limbs, mont_inv32, p);
    let z2z2 = mont_mul_256(Q.z.limbs, Q.z.limbs, mont_inv32, p);
    
    let u1 = mont_mul_256(P.x.limbs, z2z2, mont_inv32, p);
    let u2 = mont_mul_256(Q.x.limbs, z1z1, mont_inv32, p);
    
    let s1 = mont_mul_256(P.y.limbs, mont_mul_256(Q.z.limbs, z2z2, mont_inv32, p), mont_inv32, p);
    let s2 = mont_mul_256(Q.y.limbs, mont_mul_256(P.z.limbs, z1z1, mont_inv32, p), mont_inv32, p);
    
    var same_x = true;
    var same_y = true;
    for (var i = 0u; i < 8u; i = i + 1u) {
        if (u1[i] != u2[i]) { same_x = false; }
        if (s1[i] != s2[i]) { same_y = false; }
    }
    if (same_x && same_y) {
        return point_double_proj_256(P, r2, mont_inv32, p);
    }
    
    let h = sub_mod_256(u2, u1, p);
    var i = add_mod_256(h, h, p);
    i = mont_mul_256(i, i, mont_inv32, p);
    let j = mont_mul_256(h, i, mont_inv32, p);
    
    var r = sub_mod_256(s2, s1, p);
    r = add_mod_256(r, r, p);
    
    let v = mont_mul_256(u1, i, mont_inv32, p);
    
    var x3 = mont_mul_256(r, r, mont_inv32, p);
    x3 = sub_mod_256(x3, j, p);
    x3 = sub_mod_256(x3, add_mod_256(v, v, p), p);
    
    var y3 = sub_mod_256(v, x3, p);
    y3 = mont_mul_256(r, y3, mont_inv32, p);
    let s1j = mont_mul_256(s1, j, mont_inv32, p);
    let s1j2 = add_mod_256(s1j, s1j, p);
    y3 = sub_mod_256(y3, s1j2, p);
    
    var z3 = add_mod_256(P.z.limbs, Q.z.limbs, p);
    z3 = mont_mul_256(z3, z3, mont_inv32, p);
    z3 = sub_mod_256(z3, z1z1, p);
    z3 = sub_mod_256(z3, z2z2, p);
    z3 = mont_mul_256(z3, h, mont_inv32, p);
    
    var R: ProjectivePoint256;
    R.x.limbs = x3;
    R.y.limbs = y3;
    R.z.limbs = z3;
    return R;
}

// Scalar multiplication: k*P
// Inputs: k : scalar (Limbs256), P : point (x, y coordinates), r2, mont_inv32, p, p_minus_2
// Output: Q = k*P in affine coordinates
// Path: double-and-add algorithm, process scalar bits from LSB to MSB
fn scalar_mul_256(k: Limbs256, P_x: Limbs256, P_y: Limbs256, r2: array<u32, 8>, mont_inv32: u32, p: array<u32, 8>, p_minus_2: array<u32, 8>) -> Point256 {
    let P = to_projective_256(P_x, P_y, r2, mont_inv32, p);
    
    var Q: ProjectivePoint256;
    for (var i = 0u; i < 8u; i = i + 1u) {
        Q.x.limbs[i] = 0u;
        Q.y.limbs[i] = 0u;
        Q.z.limbs[i] = 0u;
    }
    
    var base = P;
    
    for (var limb_idx = 0u; limb_idx < 8u; limb_idx = limb_idx + 1u) {
        var bits = k.limbs[limb_idx];
        
        for (var bit = 0u; bit < 32u; bit = bit + 1u) {
            if ((bits & 1u) == 1u) {
                Q = point_add_proj_256(Q, base, r2, mont_inv32, p);
            }
            base = point_double_proj_256(base, r2, mont_inv32, p);
            bits = bits >> 1u;
        }
    }
    
    return to_affine_256(Q, r2, mont_inv32, p, p_minus_2);
}

// Scalar multiplication for arbitrary curve: k*P
// Inputs: k : scalar (Limbs256), P : point (x, y coordinates), curve : Curve256 parameters
// Output: Q = k*P in affine coordinates
// Path: uses curve parameters with generic scalar_mul_256
fn curve_scalar_mul(k: Limbs256, P_x: Limbs256, P_y: Limbs256, curve: Curve256) -> Point256 {
    return scalar_mul_256(
        k, P_x, P_y,
        curve.r2,
        curve.mont_inv32,
        curve.p,
        curve.p_minus_2
    );
}

@group(0) @binding(0) var<storage, read> scalars: array<Limbs256>;
@group(0) @binding(1) var<storage, read> P_x: array<Limbs256>;
@group(0) @binding(2) var<storage, read> P_y: array<Limbs256>;
@group(0) @binding(3) var<storage, read_write> Q_x: array<Limbs256>;
@group(0) @binding(4) var<storage, read_write> Q_y: array<Limbs256>;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
    let idx = gid.x;
    
    if (idx >= arrayLength(&scalars)) {
        return;
    }
    
    let Q = curve_scalar_mul(scalars[idx], P_x[idx], P_y[idx], PALLAS_CURVE);
    Q_x[idx] = Q.x;
    Q_y[idx] = Q.y;
}